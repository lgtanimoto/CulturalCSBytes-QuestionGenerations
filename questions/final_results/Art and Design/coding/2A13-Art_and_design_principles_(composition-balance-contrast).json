{
    "MQCode": "2A13",
    "learning_objective": "Use an iterative process to plan the development of a program by including others' perspectives and considering user preferences.",
    "interest_area": "Art and Design",
    "topic": "Art and design principles (composition, balance, contrast)",
    "coding": true,
    "question_str": "{\n    \"Question\": \"Alex is developing a program for an art event. The program should accept user inputs for the visual elements they want on their canvas such as line, shape, texture, color, and space. These elements will then be composed on the canvas based on balance, contrast, and other art principles. Alex wrote a function called Balance() to adjust the composition, but the program sometimes creates art pieces that are too heavy on one side. As Alex's team mate, how would you advise them to improve the iterative process while planning the development of Balance()?\",\n    \"Answer1\": \"// The Balance function should take user preferences into account and iterate through different potential arrangements until the best balance is reached.\",\n    \"Answer2\": \"// Alex should hardcode the placements of visual elements to ensure balance in the art piece.\",\n    \"Answer3\": \"// Alex should remove the Balance() function as it is too complex to manage.\",\n    \"Answer4\": \"// Alex should only rely on random placements of visual elements for a unique art piece every time.\",\n    \"CorrectAnswer\": \"1\",\n    \"Explanation\": \"To improve the iterative process, the Balance function should incorporate user preferences, such as their preferred visual elements and arrangement style. It should also iterate through different possible arrangements until reaching an optimal balance. To make the process efficient, Alex can create sub-routines for each visual element and experiment with their arrangements until a satisfactory balance is achieved.\",\n    \"code_snippet\": \"action Balance()\\\\n    while(!isBalanced())\\\\n        ShiftElements()\\\\n        if (CheckBalance())\\\\n            isBalanced = true\\\\n        end\\\\n    end\\\\nend\\\\n\\\\naction ShiftElements()\\\\n    // code to rearrange elements\\\\nend\\\\n\\\\naction CheckBalance()\\\\n    // code to evaluate balance of the current arrangement\\\\nend\"\n}"
}